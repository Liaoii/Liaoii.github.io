---
title: "访问权限控制"
catalog: true
date: 2021-04-11 14:05:05
subtitle:
header-img:
tags:
- JavaSE
---

### 为什么需要进行访问权限控制

对于客户端程序员来说，他总是希望自己所使用的那一部分类库不会出现变化，否则永远无法保证程序能够稳定运行。但对于类库的开发者来说，他总是希望对自己的代码进行不断的重构与优化，使其变得更加完美。当类库的开发者想要对自己的代码进行重构与优化时，由于不知道客户端程序员具体使用了类中的哪些成员，此时所做出的任何一个改动都有可能破坏客户端程序员的代码，也就是说，类库开发者将无法对任何事物进行改动。

为了解决这一问题，Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。此时，类库的开发者对那些客户端程序员不可用的部分进行重构与优化就不会影响到客户端程序员的代码了。

### 都有哪些访问权限修饰词

访问权限控制的等级，从最大权限到最小权限依次有：public、protected、包访问权限、private，各自能访问的范围如下：

|                | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| -------------- | -------- | -------- | ------------ | -------------- |
| **public**     | √        | √        | √            | √              |
| **protected**  | √        | √        | √            |                |
| **包访问权限** | √        | √        |              |                |
| **private**    | √        |          |              |                |

### 包

**为什么需要包**

如果将所有的类文件都放在默认包下，就需要保证每一个类的名称都不重复。这对于一个代码库而言或许可以做到，但在构建一个大型系统时往往会用到各种各样不同的代码库，且这些库往往由不同的团队编写，要保证这些团队的代码库彼此之间都不重复几乎是不可能的。

通过包可以为一个类指定名称空间。如果约定在使用类时必须在类名前加上名称空间，并且以名称空间加上类名来判断两个类是否冲突，相比于直接使用类名进行比较，其冲突的概率会大大降低。但如果多个团队之间使用了相同的名称空间，并且在该名称空间下包含了相同名称的类，那么冲突依然可能会发生。我们要做的，就是避免使用相同的名称空间，一种方案就是使用反顺序的域名作为名称空间，由于域名是独一无二的，所以名称空间也将是独一无二的，前提是不要使用其他人的域名。

**指定包**

通过**package**关键字来指定一个类的包结构，也就是名称空间。它必须是文件中除注释以外的第一句程序代码。

包名一般全部使用小写字母。

**默认包**

如果一个类没有通过package指定包，那么它就是隶属于该类所在目录的默认包之中

**包的原理以及类是如何被加载的**

首先，需要将.class文件所在的路径位置编码成package的名称，这个路径实际上是相对于环境变量中某个路径的相对路径。

当Java程序运行并且需要加载 .class 文件时，会通过包的名称与CLASSPATH中的路径共同来查找 .class 文件的位置。CLASSPATH中包含一个或多个目录，这些目录将用作查找 .class 文件的根目录，Java解释器获取包的名称并将每个句点替换成反斜杠，得到的路径再与CLASSPATH中的各个不同的路径相连接，Java解释器会在这些最终生成的路径中查找需要加载的 .class 文件。

注意，无论何时创建类，都已经通过类的包的名称指定了目录结构。必须将此类放在所指定的目录之中，且该目录必须是在以CLASSPATH开始的目录中可以查询到。

在CLASSPATH中使用jar文件时必须在类路径中将jar文件的实际名称写清楚，而不仅是指明它所在位置的目录。

**使用一个类的方式**

要使用一个类，必须指明其所在的名称空间，也就是使用一个类的全类名：

```java
public class FullQualification {
    public static void main(String[] args) {
        java.util.List list = new java.util.ArrayList<>();
        list.add("Hello");
        list.add("World");
        System.out.println(list);
    }
}
```

**通过导入来简化代码**

使用import关键字来导入一个类，就可以直接通过其类名来使用类了，这样可以使代码更简洁。

可以通过 ***** 来导入一个包里的所有类，但是**不会递归导入其子包中的类**。

```java
import java.util.ArrayList;
import java.util.*;

public class E02_UseImport {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("Hello");
        list.add("World");
    }
}
```

**导入时可能出现的冲突**

当以 ***** 形式同时导入多个类库时，如果这些类库中存在相同名称的类，那么就有可能产生冲突。但只要不使用那些存在冲突的类，便没有问题。当使用的类存在于多个通过 ***** 导入的类库中时，就必须明确指明其名称空间，有两种方式：一种是使用全类名的方式来使用类；另一种是明确导入要使用的类，但不能明确导入两个名称相同的类。

**静态导入**

```java
package com.java.util;

import java.io.PrintStream;

public class Print {
    public static void print(Object obj) {
        System.out.println(obj);
    }
    public static void print() {
        System.out.println();
    }
    public static void printnb(Object obj) {
        System.out.print(obj);
    }
    public static PrintStream printf(String format, Object... args) {
        return System.out.printf(format, args);
    }
}
```

```java
package com.java.example;

import static com.java.util.Print.*;

public class E03_StaticImport {
    public static void main(String[] args) {
        print("Available from now on!");
        print("10000");
    }
}
```

**编译单元**

Java源代码文件被称为编译单元，编译单元以 .java 为后缀。在编译单元内部可以有一个或多个类，但最多只能有一个public类。如果编译单元内有public类，则该public类的名称必须与文件的名称保持一致。当然编译单元中也可以没有public类，这些非public的类只能在当前包中被访问。

当一个 .java 文件被编译时，其中的每一个类都会产生一个以 .class 为后缀的字节码文件。因此，编译少量的 .java 文件可能会得到大量的 .class 文件。这些 .class 文件将由Java解释器进行查找、装载和解释执行。

### 访问权限修饰词

**public：接口访问权限**

使用public关键字，意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户端程序员更是如此。

**protected：继承访问权限**

protected表示把对它的访问权限赋予派生类而不是所有类。同时，相同包内的其他类可以访问protected元素。

**包访问权限**

默认访问权限也就是包访问权限没有任何关键字，对于拥有包访问权限的成员只能由同一个包中的类进行访问，对于这个包之外的所有其他类来说这个成员是private的。由于一个编译单元中的类是隶属于一个包，所以同一个编译单元中的所有类彼此之间可以相互访问。

包访问权限将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互访问。包访问权限对客户端程序员来说起到了充足的隐藏效果，客户端程序员无法访问类库中拥有包访问权限的成员。

**private：私有权限**

关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。同一个包内的其他类也无法访问private成员，当有许多人共同创建一个包的代码时，private可以防止自身的代码影响到包内其他的类。所以，可以将任何只是"助手"的方法指定为private，这样就为自己保留了修改它的权限。对于类的域来说，除非需要公开底层的实现细节，否则就应该将所有的域指定为private。

在多线程环境下，private显得尤其重要。

### 封装

封装是面向对象的三大特性之一，它将数据和方法包装进类中，并通过访问权限控制来隐藏具体的实现细节，其结果是一个同时带有特征和行为的数据类型。

### 接口与实现

通过访问权限控制来设定客户端程序员可以使用和不可以使用的界限，并以此来将接口与具体实现进行分离。客户端程序员可以使用的那一部分定义为接口，而具体实现是客户端程序员无法使用的。这样做的目的在于类库的开发者可以随意修改所有不是public的东西，而不会破坏客户端程序员的代码。

为了便于客户端程序员阅读源码，一种做法是将所有的public成员置于开头，后面跟着protected、包访问权限和private成员。这样来的使用者可以从头读起，等遇到作为内部实现细节的非public成员时停止。

这样做仅能使程序阅读起来稍微容易一些，因为接口和具体实现仍旧混合在一起。其最终的解决方案是通过interface关键字来创建接口，使用接口将客户端程序员可以访问的部分完全独立出来。

### 类的访问权限

访问权限修饰词用于类之上时可以确定该类对于客户端程序员是否是可用的，访问权限修饰词必须位于class关键字之前。对于类的访问权限与类中成员的访问权限的关系，通常是成员的访问权限要小于等于类的访问权限。但如果一个具有包访问权限的类只能用于包内，那将该类的成员的访问权限设定为public也没有关系，但该public不代表它可以被当前包以外的其他类所访问。也就是需要优先判断类的访问权限。

对于public的static成员或方法，即使类只有包访问权限，客户端程序员还是可以通过类来引用static成员或方法。

类的访问权限只能是public或者包访问权限，不能是private或者protected。